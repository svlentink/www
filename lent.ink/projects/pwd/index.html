<html>
<head>
<script type="text/javascript" src="https://cdn.lent.ink/generated/bower_components/crypto-js/crypto-js.js"></script>
<style>
section {
  width: 600px;
  margin:0 auto;
  padding: 25px;
  margin-bottom: 50px;
  border: 5px solid;
  border-radius: 10px;
  border-bottom: 0;
}
#apex, #secret { width: 350px; }
</style>
<title>Password generator</title>
</head>
<body>

<section>
<i>
Generated a password in the past?
The old version can be found
<a href='https://lent.ink/projects/pwd/v1.html'>here</a>.
</i>

<h1>Password generator</h1>

<table>
  <tr>
    <td>
      <a href='https://www.google.com/search?q=what+is+an+apex+domain'>Apex</a>
      (domain)
    </td>
    <td>
      <input id="apex" value="google.com"/>
    </td>
  </tr>
  <tr>
    <td>
      Secret phrase
    </td>
    <td>
      <input id='secret' value='some long sentence'/>
      <button onclick='eye()'>&#128065;</button>
      <button onclick='save()'>&#x1f4be;</button>
    </td>
  </tr>
  <tr>
    <td>
      Generate password
    </td>
    <td>
      
      <button onclick='fullpwd()'>full size (28)</button>
      <button onclick='shortpwd()'>short (12)</button>
      and copy to clipboard
    </td>
  </tr>
  <tr>
    <td>
      Password:
    </td>
    <td>
      <input disabled id='output' style='width:300px;'/>
    </td>
  </tr>
</table>

<script>
function genPwdHash(apex,secret,maxlength){
  var str = apex + secret
  for (var i=0;i<100;i++) {
    var hash1 = CryptoJS.SHA512(str).toString()
    console.log('First hash, the sha512sum',hash1, hash1.length)
    var hash2 = CryptoJS.SHA1(hash1).toString()
    console.log('Hash used for base64',hash2, hash2.length)
    var pairs = hash2.match(/\w{2}/g)
    var binarr = pairs.map(function(a){return String.fromCharCode(parseInt(a, 16));} )
    var binstr = binarr.join("")
    var base64 = btoa(binstr)
    if (base64.length > maxlength)
      base64 = base64.substr(base64.length - maxlength)
    if ( /[0-9]/.test(base64)
        && /[A-Z]/.test(base64)
        && /[a-z]/.test(base64) )
      break
    else {
      str += 'p'
      console.log('Adding a p as padding')
    }
  }
  return base64
}

function shortpwd(){ generate(12) }
function fullpwd(){ generate(28) }

function generate(maxlength) {
  var apex = document.getElementById('apex').value
  var secret = getSecVal()
  var pwd = genPwdHash(apex, secret, maxlength).toString()
  var outp = document.getElementById('output')
  outp.value = pwd
  outp.disabled = false
  outp.select()
  document.execCommand("Copy")
  outp.disabled = true
}
function getSecVal() {
  var secretelem = document.getElementById('secret')
  secretelem.type = 'password'
  return secretelem.value
}
function eye() {
  var e = document.getElementById("secret")
  if(e.type === 'text') return

  e.value = ''
  e.type = 'text'
}
function save() {
  localStorage.setItem('pwddatastr',getSecVal())
  alert('Saved to LocalStorage')
}

var saved = localStorage.getItem('pwddatastr')
if (saved !== null) {
  document.getElementById('secret').value = saved
  getSecVal() // make it type password instead of text
}
</script>
</section>


<section>
<h2>Is it secure?</h2>
<ul>
<li>Unique password for every website (domain), preventing reuse attacks</li>
<li>No hassle of secure backup of your passwords</li>
</ul>

The hash generated gives you up to 160bit password strength,
depending on the passphrase.
Passwords are unique for every website,
since the domain is used in the hash.
<br/>
You could have multiple passphrases,
e.g. one for all work related, one for social media etc.
<br/>
NOTE: some websites have a max length on a password,
resulting in lower possible strenght.
Services demanding a short password could indicate bad security.
</section>


<section>
<h2>How does it work?</h2>
<i>Found out later that
<a href='http://lesspass.com'>lesspass</a>
does the similar thing.
but requires more parameters and does not come preinstalled (<code>shasum</code>).</i>
<br/>
It is inspired by
<a href='https://pwdhash.github.io/website/'>Stanford PwdHash</a>
and works by doing
<br/>
<code>base64( shasum(apex.tld + PASSPHRASE) )</code>
<br/>
It is a concatenation of the domain you want a password for,
together with a phrase that you use.
This string is then used to calculate a hash.
This hash uses base16 or
<a href='https://stackoverflow.com/questions/12618321/what-pool-of-characters-do-md5-and-sha-have'>hexadecimal</a>,
resulting in 40 characters, which we convert to bas64 (28 characters).
</section>

<section>
<h2>Technical</h2>
Since multiple websites have a upperlimit of 32 characters for a password,
this tool now only supports 28 character (160bit) passwords.
<br/>
We do two SHA rounds, preventing
<a href='https://crypto.stackexchange.com/questions/47177/would-sha1-be-broken-by-sheer-brute-force-even-if-it-had-no-weaknesses-of-its-o'>brute force</a>
searching for the master passphrase (not needed atm. but makes it future proof).
<br/>
The first round (sha512sum) to prevent an offline attack when 1 or more passwords are leaked
and the second round (sha1sum) to have 40 characters base16, which we convert to base64, resulting in 28 characters.
<br/>
<code>echo -n 'apex.tldPASSPHRASE'|sha512sum|tr -d '\n -'|sha1sum|cut -f1 -d' '|xxd -r -p|base64</code>
<br/>
(to avoid storing <code>history</code>, prepend a space to <code>echo</code>)
<br/>
This provides us with 28 chars of which the last one is a special char ('=').


<h3>Padding</h3>
We tested this with 1M records
<br/>
<code>for i in {1..1000000};do echo -n $i|shasum|xxd -r -p|base64;done</code>
and found out that 9858 have no number [0-9],
0 have no letter [a-z]
and 2 have no capital letter [A-Z].
To be sure that all three type of characters are present,
we append
<code>|grep [0-9]|grep [A-Z]|grep [a-z]</code>
to our initial command.
If we now get no output (probability of 1%),
we know one of the character types was missing.
We solve this by prepending a 'p' (referring to padding)
to our initial input, giving us 'apex.tldPASSPHRASEp'.
<br/>
But don't worry, the tool above does this for you,
it's just to explain the inner working of this tool.

<h3>Short, 12 character password</h3>
Some services have a password limit,
ranging from acceptable (e.g. 32 at digid.nl or namesilo.com)
to short (e.g. 20 at paypal.com and 16 at microsoftonline.com).
<br/>
When 28 chars. is too long,
we reduce it to 12, which should always fit.
The same padding technique applies here,
making it occur more often for shorter passwords.
<br/>
To achieve this on your terminal,
just prepend
"<code>|cut -c17-28</code>"
to the command.
</section>

<section>
<h2>What about a password manager?</h2>
The motivation for this password manager was the backup requirement
of normal password managers,
which need to be done secure.
This solution does not have this requirement,
you just remember the master passphrase(s).
<br/>
Disadvantages compared to password manager;
<ul>
<li>When your secret sentence is compromised,
one could generate all your passwords
(the same goes for your password on your online password manager)</li>
<li>Your sentence unlocks the power to generate all your passwords,
also the passwords for not yet existing services
(not sure if this is an issue)</li>
<li>password managers provide a list of all your services
(with this tool you should keep a list for yourself/heirs)</li>
<li>This password mechanism allows one to generate them on the terminal
and other insecure places, which could be a risk</li>
<li>Just like a regular password manager that generates random passwords,
the password cannot be memorized</li>
<li>This system allows you to use multiple master passwords (e.g. social, work, finance, team1, team2 etc.)
however, for teams, this would result in more password rotations.</li>
<br/>
Other disadvantages;
<li>A key based hash (HMAC) or slow hash (Argon2, [S|B]crypt, PBKDF2)
would make this system more secure,
however,
<code>shasum</code> was chosen,
since it comes pre-installed on most machines</li>

</ul>

</section>

</body>

</html>
